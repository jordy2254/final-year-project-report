\section{Design}
The following chapter is going to cover the design process for the development of the application. By the end of this design chapter it will be clear of the chosen technologies and a high level knowledge of how the system will function will be understood. As part of the design existing map applications such as Google maps \& waze where looked at. Looking at existing map applications allowed the designs to be inspired from different sections and provide and idea of how these systems work, one great side effect of using these systems as inspiration is that it's hoped the system will be clear how to use by user's that have expierence with them.

\subimport{./userstories/}{userstories.tex}

\subsection{Decided technologies}
Programming languages and libraries are very varied and people have many opinions on these. In general a chosen technology, library or language comes down to the developers preference/what they most comfortable in. Several languages have been decided for the final product and the below section is highlighting these along with what influenced the decision.

\subsubsection{Security}
Many people these days like SSO systems allowing them to sign in from their social media accounts. For this reason an SSO provider will be used in order to protect the REST API and web application.

\subsubsection{Rest API}
The rest API is going to be developed using Golang, Golang support module development, is easy to work with and has a performance between Java and C. The author has an interest in this language and wants to reinforce in it and feels this is an excellent use case for this, and will allow expandability of the application in the future.

\subsubsection{Web Application}
The web application will be written within Typescript using the react libary. The main influencing decision for this is the author's interest in keeping up with current popular technologies and feels this would be a good chance to implement the library and develop a progressive web app, and learn about the react libary.

\subsubsection{Android Application}
It has been decided the android application will be written using the traditional Java method as opposed to the current default language of Kotlin, the reason for this is because the author is more familiar with Java and is already using new technologies for the web application. Time limitations mean it's not practical to learn Kotlin in addition to the other technologies for this project rendering it out of scope.

\pagebreak
\subsection{Architecture overview}
With the system being modular and containing several key parts that need to function appropriately together and architecture overview diagram has been generated to show how the system intends to work. This architecture overview is useful for understanding the base system that has been implemented.

\includegraphics[width=\linewidth]{./images/designs/ArchitectureOverview.png}

\subsection{Data Storage \& Data Structure}
Before development of any new functionality or system it's important to consider the data that's required. The format and quality of the data structure is important the success of a system and is also important to ensure maintainability and expansion is possible in the future. One common storage structure for data is a relational database, this allows quick and easy access and filtering of the data within and is the industry standard. A key method of designing these databases is with an entity relationship diagram (ERD), below is and ERD for the decided data structure for the project.

\includegraphics[width=\linewidth]{./images/designs/erddetailed.png}\\
The above diagram contains all the key information required to create the initial database for the project, in addition it also gives and insight for all the data needed in the base model for anything that uses this data from the API, as such will serve as a base for creating the Java classes and Golang structs. 

Finally the above diagram also highlights some of the design considerations that where made to make development of the project faster, the first of these was to store rooms as rectangles with overlays as another rectangle, this achieves a more simplistic data structure and types to work with in order to make building the prototype faster. Looking at existing indoor maps of a range of locations such as UWE on google maps, shows that most rooms within a building are rectangular with indents cut out of them, as such a majority of situations will be covered by this data structure,as this is a prototype small limitations are out of scope however if this was to become a business based implementation changes would be required to cover certain edge cases such as the hexagon at UWE, this being said the system will still be capable of demonstrating it's potential within the industry as a prototype.

\subsubsection{Other Data storage}
The rest API will feature the data structure and be connected to a database as above, to allow for quick access and query of data. This isn't needed for the android application and as such the data returned from the rest API will be stored as JSON files on the device. This allows quick serialisation/de-serialisation of data whilst maintaining a simple storage method. This is justified by the fact that the map data will not need to be queried unless already loaded into memory. Using a database would also complicate the re-synchronisation of changed map data.

\newpage
\subsection{REST API Design}
With the data structure defined above, the rest API for this project will perform mostly CRUD operations protected using Auth0, as such no direct design will be done for the rest API, the aim of this section is to give a basic overview of how the rest API will function.

Each data layer will also contain the heirarchial format IE: room update URL would be:\\ /map/buildings/rooms/\{id\}. Each piece of data will contain a route to create, retrieve, update \& delete the piece of data. All routes will be protected via a JWT token which will be supplied by the react application, example URL's and methods for the map itself can be viewed below.

\begin{longtable}{| p{0.2\linewidth} | p{0.1\linewidth} | p{0.7\linewidth}|}
	\hline
	End point & Methods & Description \& Returned data\\\hline
	/maps/\{id\} & GET & Returns whole map data including all child components for the requested ID\\\hline
	/maps/\{id\} & POST & Updates the map only omiting any child elements  returning the new updated map data\\\hline
	/maps/\{id\} & DELETE & Deletes the resource from the service\\\hline
	/maps/ & POST & An empty request will create a blank map, a request containing JSON will be parsed to a full map saving the full map to the database returning new map data\\\hline
	
\end{longtable}

An additional route of just /maps will exist to retrieve top level map data for all maps of the logged in user. This route will have a HTTP method of GET and will take no URL parameters or information, it will however be protected by a JWT token.
Finally one last route will exist ontop of the map which will have the URL of /map/sync which will be used by the android application to syncronise new maps, it will be a post function and will contain formatted json of the mapID and password required, this route will not require any middleware and will be open to use.

\subsection{UI Designs}
There exists a range of map applications already implemented including Google maps, Waze \& apple Maps. Each mapping application has a similar UI but they do vary slightly. \appendixtemp contains some screenshots of each of these applications. With large companies having the budget to design optimum and efficient UI's the final product of the mapping system will be a combination of these UI's. Both the android application and web application will have there designs as images, and have an explanation of any functionality/links that are not clear from the designs. All designs have been carefully considered to ensure a complete fulfilment of the requirements.

\pagebreak
\subsubsection{Android Application}
Below is a range of designs for the android application for the large parts of functionality. These designs are more detailed than the web application due to there being less "layers" of UI. The main functionality required for the android app is the ability to select maps, search, move around and set points. The below designs cover all of those requirements \\
\\\underline{Map Selection}
\begin{center}
	\fbox{\includegraphics[width={0.25\linewidth}]{./images/designs/ui/android/MapSelection.png}}
	\fbox{\includegraphics[width={0.25\linewidth}]{./images/designs/ui/android/MapSelectionWithmaps.png}}
\end{center}

The above two views show the basic map selection screen presented when the activity starts. The first screen show's the view if the user has synchronised no maps as highlighted in the prompt the user can add new maps by clicking the plus button on the top menu bar. The view for the new map synchronisation can be viewed in the below screenshot.\\

The second view displays to the user the synchronised maps. This view has several extra options, as can be seen by the icons each map has an independent delete and resynchronise button. Additionally the user has the option to filter their synchronised maps which will bring up a filters panel. Again the design for the filters pane can be view below.

\begin{center}
	\fbox{\includegraphics[height=6cm]{./images/designs/ui/android/AddMap.png}}
	\fbox{\includegraphics[height=6cm]{./images/designs/ui/android/mapFilterOveralay.png}}
\end{center}

\underline{Location}
\begin{center}
	\fbox{\includegraphics[width={0.3\linewidth}]{./images/designs/ui/android/Map.png}}
\end{center}
 The above image demonstrates the base for the actual location/map view section of the software. The design features a hamburger menu that can expanded to detail the start and end location. By default if the user is found to be within the proximity of the maps sensors the location and direction will be presented on the map. The design features all the functionality setout within the requirements, allowing the use of directions, searching, changing route options (Design for overlay below). 

Sub Screens\\
\fbox{\includegraphics[height=6cm]{./images/designs/ui/android/RouteOptions.png}}\\
\fbox{\includegraphics[height=6cm]{./images/designs/ui/android/RouteSearch.png}}\\

\subsubsection{Web Application}
The web application has 2 core states, the first is the map selection screen which can be seen below:\\
\fbox{\includegraphics[width=\linewidth]{./images/designs/ui/web/MapSelection.png}}

As can be seen the design features 3 options for creating a map, the first is a blank empty map, the second is from an exported json file from an existing map, and the third is from a base template. It's important to ensure the system supports a templating system for the future so basic maps can be created from these templates.


The final key component of this design is the selection view for exiting maps the user has, hovering over one of these will allow renaming \& deleting from buttons on the top right, clicking anywhere else will load the map.

\fbox{\includegraphics[width=\linewidth]{./images/designs/ui/web/MapEditor.png}}
The second state can be seen above and is a basic design for the editing portion of the web app, the web app will feature canvas rendering of the existing map, and will feature a series of tools to move the map, select rooms, edit path and more. In addition to these tools the right hand side will hold any key settings in a hierarchy view where a building can be selected which displays the options for a building plus selection list for child components. 

The map name is editable by clicking on the text for the map name. QR generation is also a feature, this is to match \ref{android:sync} where the android device can scan a bar code that will automatically boot the app and synchronise the map.

Designs for the Dashboard as defined in requirement \ref{web:dashboard} have been omitted due to having a priority of could. The designs for this element will be visited if there is time in the future to complete this requirement

\subsection{Important design considerations}
As with any system making it generic and expandable is something to consider from an early stage. Not doing this can be detrimental to the long term standing of the code making it more difficult to expand and improve the application with time.

One key area for expandability was found within the research \citetemp technology is constantly changing as such Bluetooth is the optimal solution currently although that will change in the future. For this reason it's important to consider the integration of Bluetooth and potentially other sensor's into the positioning calculation. For this reason several interfaces will exist on the implementation, the lowest interface will contain a list of scan and distance services, passing all sensor ID's to them so results can be filtered. The idea of the scan and distance service is to return a set of formatted data back from it's implementation, this means any sensor can be used, and calculation of distance can be changed per sensor type. One the location service has ran these functions for all the different sensors the system can then use this data to calculate the location as specific in the research \citetemp.

Another important design approach is to keep the code as independent from the system as possible, doing so will allow the ability to create a library that is used in the future. It also means that the system is easier to maintain and can be ported to other systems that run the JDK with minimal work. Finally it's important to ensure a clear distinction between the view and logic, implementing a new UI shouldn't interfere with any core system logic, methods exist for this already as such a Model View Controller approach will be used for the whole system this again ensures expandability and ease of development in the future.